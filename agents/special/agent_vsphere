#!/usr/bin/python
# encoding: utf-8
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2010             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import sys
import argparse

parser = argparse.ArgumentParser(description='Check_MK vSphere Agent')
group = parser.add_argument_group()
# group.add_argument('-p', '--port', type=int, help="Port Number of vSphere Server")
group.add_argument('-i', 
                    help="Modules to query. This is a comma separated list of hostsystem, "
                         "virtualmachine and storage. Default is to query all modules.")

parser.add_argument('-u','--user', 
                    help="Username for vSphere login")

parser.add_argument('-s','--secret', 
                    help="Secret/Password for vSphere login")

parser.add_argument('-D', '--direct', action="store_true",
                    help="Assume a directly queried host system (no vCenter). In this "
                         "we expect data about only one HostSystem to be found and do "
                         "not create piggy host data for that host.")
                    
parser.add_argument('--debug', action="store_true", 
                    help="Debug mode: let Python exceptions come through")

parser.add_argument('HOST', 
                    help="Host name or IP address of vCenter or VMWare HostSystem")

params = vars(parser.parse_args())


try:
    from pysphere import VIServer, VIProperty, MORTypes
    from pysphere.resources import VimService_services as VI
except: 
    sys.stderr.write("pysphere API not found. Please install and try again.\n")
    sys.exit(1)

host = VIServer()

object_collection = {} 

try:
    host.connect(params['HOST'], params['user'], params['secret'])
except:
    if params['debug']:
        raise
    sys.stderr.write("Cannot connect to vSphere Server. May the wrong credentials. Please correct and make a reinventory.\n")
    sys.exit(1)

print "<<<check_mk>>>"
print "Version: %s" % host.get_api_version()
print "AgentOs: %s " % host.get_server_type()

# import inspect, pprint
# for x in host._retrieve_properties_traversal(property_names=[], obj_type = MORTypes.ManagedEntity):
#     print x.Obj
#     print inspect.getmembers(x)
# sys.exit(17)

# hosts = host.get_hosts()
# pprint.pprint(inspect.getmembers(VIProperty(host, hosts.keys()[0]).hardware))
# sys.exit(1)

#for p in VIProperty(host, hosts.keys()[0]).network:
    # print host.get_resource_pools(p)
    # for n in p:
 #       pprint.pprint(inspect.getmembers(p))

# print p
# print hosts


# sys.exit(1)



def output_mors(what, properties, direct=False): 
    if what == "hostsystem":
        obj_type = MORTypes.HostSystem
    elif what == "networking":
        obj_type = MORTypes.HostNetworkSystem
    else:
        obj_type = MORTypes.VirtualMachine

    count = 0
    sections = []
    for mor in host._retrieve_properties_traversal(property_names=properties.keys(), obj_type=obj_type):
        count += 1
        # Parse result into a dictionary. Key is the property name,
        # value is the value (some custom Python classes)
        data = {}
        for p in mor.PropSet:
            # Convert property value using specified conversion function
            data[p.Name] = properties[p.Name](p.Val)

        # Get the name of this Host/VirtualMachine
        # May there a comments in the field, so split at whitespace
        try:
            name = data["name"].split()[0]
            object_collection[name] = (what, data['name'])
        except:
            pass
        
        # Output multiplexed Check_MK Agent output (new in version 1.2.3i1)
        if direct:
            if count > 1:
                raise Exception("You specified --direct, but there is more than one HostSystem!")
        else:
            print '<<<<%s>>>>' % name

        print '<<<esx_vsphere_%s>>>' % what
        items = data.items()
        items.sort()
        for name, value in items:
            if type(value) == tuple:
                sections.append(value)
            else:
                print '%s %s' % (name, value)

    # pprint.pprint(sections)
    for section_name, section_lines in sections:
        print '<<<%s>>>' % section_name
        for line in section_lines:
            print line


def conv_multipath(value):
    return " ".join(["%s %s" % (p.Name, p.PathState) for p in value.HostMultipathStateInfoPath])

def conv_numeric_sensor_info(value):
    # import inspect, pprint
    lines = []
    for sensor in value.HostNumericSensorInfo:
        if not hasattr(sensor, "HealthState"):
            continue # should never happen. If happens, sensor not interesting for monitoring
        if sensor.HealthState.Key == "green":
            continue # just output sensors with issuse - saves lots of data

        line = '%s;%s;%s;%s;%s;' % ( sensor.Name, sensor.BaseUnits, sensor.CurrentReading, sensor.SensorType, sensor.UnitModifier)
        if hasattr(sensor, "RateUnits"):
            line += sensor.RateUnits
        line += ";%s;%s;%s" % (sensor.HealthState.Key, sensor.HealthState.Label, sensor.HealthState.Summary)
        lines.append(line)

        # print inspect.getmembers(sensor)
    return ('esx_vsphere_sensors:sep(59)', lines)

    # return pprint.pformat(inspect.getmembers(value))

if params['i'] == None:
    mortypes = [ 'hostsystem', 'virtualmachine', 'storage' ]
else:
    mortypes = params['i'].split(',')

if "hostsystem" in mortypes:
    output_mors("hostsystem", {
      "name": str,

      "overallStatus": str,
      "runtime.powerState": str,
      "runtime.inMaintenanceMode": str,

      "summary.quickStats.overallMemoryUsage":     str,
      "hardware.memorySize": str,

      "summary.quickStats.overallCpuUsage": str,
      #"summary.quickStats.overallCpuDemand": str,
      #"summary.quickStats.sharedMemory": str,
#      "summary.quickStats.guestMemoryUsage": str,

      "config.multipathState.path": conv_multipath,

      "hardware.cpuInfo.numCpuPackages": str,
      "hardware.cpuInfo.numCpuCores": str,
      "hardware.cpuInfo.numCpuThreads": str,
      "hardware.cpuInfo.hz": str,

      "runtime.healthSystemRuntime.systemHealthInfo.numericSensorInfo" : conv_numeric_sensor_info,

      #"summary.quickStats.uptime": str,
    }, params['direct'])

# Warning: we have no guarantee that all properties are always
# output. For example if a VM is powered off, the only property
# we get is summary.runtime.powerState
if "virtualmachine" in mortypes:
    output_mors("virtualmachine", {
     "name": str,
     "guestHeartbeatStatus": str,
     "summary.quickStats.overallCpuUsage": str,
     "summary.quickStats.overallCpuDemand": str,
     "summary.quickStats.uptimeSeconds": str,

      "summary.quickStats.overallCpuUsage": str,
      "summary.quickStats.overallCpuDemand": str,
      "summary.quickStats.guestMemoryUsage": str,
      "summary.quickStats.hostMemoryUsage": str,
      "summary.quickStats.distributedCpuEntitlement": str,
      "summary.quickStats.distributedMemoryEntitlement": str,
      "summary.quickStats.staticCpuEntitlement": str,
      "summary.quickStats.staticMemoryEntitlement": str,
      "summary.quickStats.privateMemory": str,
      "summary.quickStats.sharedMemory": str,
      "summary.quickStats.swappedMemory": str,
      "summary.quickStats.balloonedMemory": str,
      "summary.quickStats.consumedOverheadMemory": str,
      "summary.quickStats.compressedMemory": str,

      # Virtual machine configuration
      "config.hardware.memoryMB": str,
      "config.hardware.numCPU": str,
      "config.hardware.numCoresPerSocket": str,
      #"config.hardware.hwVersion": str,
      #"config.hardware.guestId": str,
      #"config.hardware.uuid": str,

      "summary.runtime.powerState": str,
    })


print "<<<<>>>>"

print "<<<local>>>"
for name, data in object_collection.items():
    print "0 %s-%s - OK: collecting piggyback data for %s" % (data[0], name, data[1])
host.disconnect()
